#include <WiFi.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>

// Configurações Wi-Fi e MQTT
const char* SSID = "Wokwi-GUEST";      // Troque pelo nome da sua rede
const char* PASSWORD = "";             // Troque pela senha da sua rede
const char* BROKER_MQTT = "52.146.16.14";  // IP do broker MQTT
const int BROKER_PORT = 1883;
const char* TOPICO_SUBSCRIBE = "/TEF/quiz/cmd";  // Tópico de perguntas
const char* TOPICO_PUBLISH = "/TEF/quiz/resposta"; // Tópico para enviar resultados
const char* ID_MQTT = "ESP32_Quiz";

// Variáveis MQTT
WiFiClient espClient;
PubSubClient MQTT(espClient);

// Estrutura para armazenar pergunta recebida
struct Pergunta {
  int id;
  String pergunta;
  String opcoes[4];
  String respostaCorreta;
};
Pergunta perguntaAtual;
volatile bool novaPergunta = false;

// Prototipos
void setupWiFi();
void setupMQTT();
void reconnectMQTT();
void mqttCallback(char* topic, byte* payload, unsigned int length);
void exibirPergunta();
void receberResposta();

void setup() {
  Serial.begin(115200);
  delay(1000);

  WiFi.mode(WIFI_STA);
  setupWiFi();

  MQTT.setServer(BROKER_MQTT, BROKER_PORT);
  MQTT.setCallback(mqttCallback);
  reconnectMQTT();

  Serial.println("Aguardando perguntas do Postman via MQTT...");
}

void loop() {
  if (!MQTT.connected()) {
    reconnectMQTT();
  }
  MQTT.loop();

  if (novaPergunta) {
    // bloqueia aqui para ler a resposta do usuário, mas mantemos MQTT.loop() dentro de receberResposta()
    exibirPergunta();
    receberResposta();
    novaPergunta = false;
  }
}

// Conexão Wi-Fi
void setupWiFi() {
  WiFi.begin(SSID, PASSWORD);
  Serial.print("Conectando ao Wi-Fi");
  unsigned long start = millis();
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
    // opcional: timeout de 30s
    if (millis() - start > 30000UL) {
      Serial.println("\nTimeout ao conectar Wi-Fi. Tentando de novo...");
      start = millis();
      WiFi.disconnect();
      WiFi.begin(SSID, PASSWORD);
    }
  }
  Serial.println("\nConectado ao Wi-Fi!");
  Serial.print("IP: ");
  Serial.println(WiFi.localIP());
}

// Conexão MQTT
void reconnectMQTT() {
  while (!MQTT.connected()) {
    Serial.print("Conectando ao broker MQTT...");
    if (MQTT.connect(ID_MQTT)) {
      Serial.println("Conectado!");
      if (MQTT.subscribe(TOPICO_SUBSCRIBE)) {
        Serial.print("Inscrito no tópico: ");
        Serial.println(TOPICO_SUBSCRIBE);
      } else {
        Serial.println("Falha ao inscrever no tópico!");
      }
    } else {
      Serial.print("Falha, rc=");
      Serial.print(MQTT.state());
      Serial.println(" Tentando novamente em 2s");
      delay(2000);
    }
  }
}

// Callback MQTT para receber pergunta
void mqttCallback(char* topic, byte* payload, unsigned int length) {
  Serial.print("Mensagem recebida no tópico: ");
  Serial.println(topic);

  // copiamo o payload para um buffer com null-terminator para desserializar com segurança
  const size_t bufSize = (size_t)length + 1;
  char msg[bufSize];
  memcpy(msg, payload, length);
  msg[length] = '\0';

  Serial.print("Payload raw: ");
  Serial.println(msg);

  // ajustar tamanho do documento dependendo do JSON esperado
  DynamicJsonDocument doc(1024);
  DeserializationError error = deserializeJson(doc, msg);
  if (error) {
    Serial.print("Erro ao processar JSON: ");
    Serial.println(error.c_str());
    return;
  }

  // Inicializa com valores seguros
  perguntaAtual.id = 0;
  perguntaAtual.pergunta = "";
  for (int i = 0; i < 4; i++) perguntaAtual.opcoes[i] = "";

  // Preenche a estrutura de pergunta (checa se campos existem)
  if (doc.containsKey("id")) {
    perguntaAtual.id = doc["id"].as<int>();
  }
  if (doc.containsKey("pergunta")) {
    perguntaAtual.pergunta = doc["pergunta"].as<const char*>();
  }

  // Preenche opções (se vier array)
  if (doc.containsKey("opcoes") && doc["opcoes"].is<JsonArray>()) {
    JsonArray arr = doc["opcoes"].as<JsonArray>();
    for (size_t i = 0; i < 4; i++) {
      if (i < arr.size()) {
        perguntaAtual.opcoes[i] = arr[i].as<const char*>();
      } else {
        perguntaAtual.opcoes[i] = "";
      }
    }
  }

  // Trata 'resposta' que pode ser um índice (1..4) ou o texto da resposta
  perguntaAtual.respostaCorreta = "";
  if (doc.containsKey("resposta")) {
    if (doc["resposta"].is<int>()) {
      int idx = doc["resposta"].as<int>();
      if (idx >= 1 && idx <= 4) {
        perguntaAtual.respostaCorreta = perguntaAtual.opcoes[idx - 1];
      } else {
        // se índice inválido, guarda como string bruta
        perguntaAtual.respostaCorreta = String(idx);
      }
    } else {
      // assume string
      perguntaAtual.respostaCorreta = doc["resposta"].as<const char*>();
    }
  }

  novaPergunta = true;
}

// Exibe pergunta e opções no Serial
void exibirPergunta() {
  Serial.println();
  Serial.print("Pergunta (ID ");
  Serial.print(perguntaAtual.id);
  Serial.print("): ");
  Serial.println(perguntaAtual.pergunta);
  for (int i = 0; i < 4; i++) {
    Serial.print(i + 1);
    Serial.print(": ");
    Serial.println(perguntaAtual.opcoes[i]);
  }
  Serial.println("Digite o número da resposta correta e pressione ENTER:");
}

// Recebe resposta do usuário e valida (mantém MQTT ativo enquanto espera)
void receberResposta() {
  while (true) {
    // mantém MQTT vivo
    if (!MQTT.connected()) {
      reconnectMQTT();
    }
    MQTT.loop();

    if (Serial.available()) {
      String entrada = Serial.readStringUntil('\n');
      entrada.trim();
      int opcaoEscolhida = entrada.toInt();

      if (opcaoEscolhida < 1 || opcaoEscolhida > 4) {
        Serial.println("Opção inválida! Tente novamente:");
        continue;
      }

      String respostaEscolhida = perguntaAtual.opcoes[opcaoEscolhida - 1];

      // compara strings (caso respostaCorreta também seja texto da opção)
      bool correta = false;
      if (respostaEscolhida == perguntaAtual.respostaCorreta) {
        correta = true;
      } else {
        // às vezes respostaCorreta veio como índice (string numerica) ou texto diferente;
        // se respostaCorreta for numérica, compara índices também
        if (perguntaAtual.respostaCorreta.length() > 0 && perguntaAtual.respostaCorreta.toInt() == opcaoEscolhida) {
          correta = true;
        }
      }

      if (correta) {
        Serial.println("✔ Resposta correta!");
        // publica uma resposta simples. Se quiser JSON, pode-se mudar aqui.
        MQTT.publish(TOPICO_PUBLISH, "Correto");
      } else {
        Serial.print("✘ Resposta incorreta! A correta é: ");
        Serial.println(perguntaAtual.respostaCorreta);
        MQTT.publish(TOPICO_PUBLISH, "Incorreto");
      }
      break;
    }

    delay(10); // evita loop ocupado
  }
}
