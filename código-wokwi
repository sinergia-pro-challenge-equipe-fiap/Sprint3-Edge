#include <WiFi.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <HTTPClient.h>

// Config Wi-Fi
const char* SSID = "Wokwi-GUEST";
const char* PASSWORD = "";

// Config MQTT
const char* BROKER_MQTT = "52.146.16.14";
const int BROKER_PORT = 1883;
const char* TOPICO_PERGUNTA = "/TEF/quiz/cmd";
const char* TOPICO_RESPOSTA_USUARIO = "/TEF/quiz/respostaUsuario";
const char* TOPICO_RESULTADO = "/TEF/quiz/resposta";
const char* ID_MQTT = "ESP32_Quiz";

// Orion (HTTP) â€” onde vamos criar entidades Resposta para que STH registre
const char* ORION_HOST = "52.146.16.14";
const int ORION_PORT = 1026;

// LED pins (ajuste conforme sua placa)
const int PIN_LED_RED = 13;   // pino do LED vermelho
const int PIN_LED_GREEN = 12; // pino do LED verde

WiFiClient espClient;
PubSubClient MQTT(espClient);

// Estrutura da Pergunta
struct Pergunta {
  int id;
  String pergunta;
  String opcoes[4];
  String respostaCorreta;
};
Pergunta perguntaAtual;
volatile bool novaPergunta = false;

// HistÃ³rico de respostas
struct Historico {
  int id;
  String respostaUsuario;
};
Historico historico[50];
int historicoCount = 0;

// Prototypes
void setupWiFi();
void reconnectMQTT();
void mqttCallback(char* topic, byte* payload, unsigned int length);
void exibirPergunta();
void verificarResposta(String respostaUsuario);
void enviarRespostaAoOrion(int perguntaId, const String &respostaUsuario, const String &resultado);

void setup() {
  Serial.begin(115200);
  delay(1000);

  pinMode(PIN_LED_RED, OUTPUT);
  pinMode(PIN_LED_GREEN, OUTPUT);
  digitalWrite(PIN_LED_RED, LOW);
  digitalWrite(PIN_LED_GREEN, LOW);

  WiFi.mode(WIFI_STA);
  setupWiFi();

  MQTT.setServer(BROKER_MQTT, BROKER_PORT);
  MQTT.setCallback(mqttCallback);
  reconnectMQTT();

  Serial.println("âœ… ESP32 pronto. Aguardando perguntas...");
}

void loop() {
  if (!MQTT.connected()) {
    reconnectMQTT();
  }
  MQTT.loop();

  if (novaPergunta) {
    exibirPergunta();
    novaPergunta = false;
  }
}

void setupWiFi() {
  WiFi.begin(SSID, PASSWORD);
  Serial.print("Conectando ao Wi-Fi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nâœ… Wi-Fi conectado!");
  Serial.print("IP local: ");
  Serial.println(WiFi.localIP());
}

void reconnectMQTT() {
  while (!MQTT.connected()) {
    Serial.print("Conectando ao broker MQTT...");
    if (MQTT.connect(ID_MQTT)) {
      Serial.println("âœ… Conectado!");
      MQTT.subscribe(TOPICO_PERGUNTA);
      MQTT.subscribe(TOPICO_RESPOSTA_USUARIO);
    } else {
      Serial.print("Falha, rc=");
      Serial.print(MQTT.state());
      Serial.println(" Tentando novamente em 2s...");
      delay(2000);
    }
  }
}

void mqttCallback(char* topic, byte* payload, unsigned int length) {
  char msg[length + 1];
  memcpy(msg, payload, length);
  msg[length] = '\0';

  Serial.printf("\nðŸ“© Mensagem recebida em [%s]: %s\n", topic, msg);

  DynamicJsonDocument doc(1024);
  DeserializationError error = deserializeJson(doc, msg);
  if (error) {
    Serial.print("Erro JSON: ");
    Serial.println(error.c_str());
    return;
  }

  if (String(topic) == TOPICO_PERGUNTA) {
    perguntaAtual.id = doc["id"] | 0;
    perguntaAtual.pergunta = doc["pergunta"] | "";
    for (int i = 0; i < 4; i++) {
      perguntaAtual.opcoes[i] = doc["opcoes"][i] | "";
    }
    perguntaAtual.respostaCorreta = doc["resposta"] | "";
    novaPergunta = true;
  } else if (String(topic) == TOPICO_RESPOSTA_USUARIO) {
    String respostaUsuario = doc["resposta"] | "";

    // Verificar se jÃ¡ foi respondida
    for (int i = 0; i < historicoCount; i++) {
      if (historico[i].id == perguntaAtual.id) {
        Serial.println("\nâš  Pergunta jÃ¡ respondida anteriormente:");
        Serial.printf("Pergunta: %s\n", perguntaAtual.pergunta.c_str());
        Serial.printf("Resposta correta: %s\n", perguntaAtual.respostaCorreta.c_str());
        Serial.printf("Resposta enviada anteriormente: %s\n", historico[i].respostaUsuario.c_str());
        return;
      }
    }

    // Se nÃ£o respondeu ainda
    verificarResposta(respostaUsuario);

    if (historicoCount < 50) {
      historico[historicoCount].id = perguntaAtual.id;
      historico[historicoCount].respostaUsuario = respostaUsuario;
      historicoCount++;
    }
  }
}

void exibirPergunta() {
  Serial.println("\n--- NOVA PERGUNTA ---");
  Serial.printf("ID %d: %s\n", perguntaAtual.id, perguntaAtual.pergunta.c_str());
  for (int i = 0; i < 4; i++) {
    Serial.printf("%d: %s\n", i + 1, perguntaAtual.opcoes[i].c_str());
  }
  Serial.println("ðŸ‘‰ Envie sua resposta pelo Postman (MQTT) no tÃ³pico /TEF/quiz/respostaUsuario");
}

void verificarResposta(String respostaUsuario) {
  Serial.printf("\nðŸ“ Resposta recebida: %s\n", respostaUsuario.c_str());

  bool correta = (respostaUsuario == perguntaAtual.respostaCorreta);
  String resultadoStr = correta ? "Correto" : "Incorreto";

  // Publish result via MQTT
  MQTT.publish(TOPICO_RESULTADO, resultadoStr.c_str());

  // Acende LEDs
  if (correta) {
    digitalWrite(PIN_LED_GREEN, HIGH);
    digitalWrite(PIN_LED_RED, LOW);
  } else {
    digitalWrite(PIN_LED_GREEN, LOW);
    digitalWrite(PIN_LED_RED, HIGH);
  }

  // MantÃ©m o LED aceso por 3 segundos
  delay(3000);
  digitalWrite(PIN_LED_GREEN, LOW);
  digitalWrite(PIN_LED_RED, LOW);

  // Envia entidade Resposta para o Orion (HTTP) â€” para o STH armazenar depois
  enviarRespostaAoOrion(perguntaAtual.id, respostaUsuario, resultadoStr);

  // Log no Serial
  if (correta) {
    Serial.println("âœ” Resposta correta!");
  } else {
    Serial.printf("âœ˜ Resposta incorreta! Correta era: %s\n", perguntaAtual.respostaCorreta.c_str());
  }
}

void enviarRespostaAoOrion(int perguntaId, const String &respostaUsuario, const String &resultado) {
  // create unique id with timestamp
  unsigned long ts = millis();
  String entityId = "Resposta:" + String(perguntaId) + ":" + String(ts);

  DynamicJsonDocument doc(512);
  doc["id"] = entityId;
  doc["type"] = "Resposta";

  JsonObject pId = doc.createNestedObject("perguntaId");
  pId["value"] = String("Pergunta:") + String(perguntaId);

  JsonObject rUser = doc.createNestedObject("respostaUsuario");
  rUser["value"] = respostaUsuario;

  JsonObject res = doc.createNestedObject("resultado");
  res["value"] = resultado;

  // Optionally add timestamp attribute (STH/Orion may set its own)
  JsonObject timeAttr = doc.createNestedObject("timestamp");
  timeAttr["value"] = String(millis()); // just as extra info

  String payload;
  serializeJson(doc, payload);

  // Perform HTTP POST
  HTTPClient http;
  String url = String("http://") + ORION_HOST + ":" + String(ORION_PORT) + "/v2/entities";
  http.begin(url);
  http.addHeader("Content-Type", "application/json");
  // optional FIWARE headers:
  http.addHeader("fiware-service", "smart");
  http.addHeader("fiware-servicepath", "/");

  int code = http.POST(payload);
  if (code > 0) {
    Serial.printf("Orion POST code: %d\n", code);
    if (code >= 200 && code < 300) {
      Serial.println("Resposta enviada ao Orion com sucesso.");
    } else {
      String resp = http.getString();
      Serial.printf("Orion responded: %s\n", resp.c_str());
    }
  } else {
    Serial.printf("Falha ao enviar para Orion. erro: %s\n", http.errorToString(code).c_str());
  }
  http.end();
}
